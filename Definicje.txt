Specyfikatory dostępu (ang. access specifiers):
    - public - Definicje dostępne są dla każdego
    - private - Dostęp jedynie wewnątrz klasy       (Klasy dziedzicące nie mają do nich dostępu)
    - protected - Podobnie do private               (Klasy dziedzicące mają do nich dostęp)

    - Jeśli nie został podany żaden z powyższych, ustawiany jest specyfikator domyślny - package access.
        Do składowych pakietowych mogą odwoływać się inne klasy z tego samego pakietu. Poza nim, widoczne są jako prywatne.


Tworzenie obiektu składowego - umieszczanie obiektu (powstałego z klasy) wewnątrz nowej klasy. Nowa klasa może być zbudowana z dowolenj liczby obiektów (niezależnie od ich typów), połączonych w dowolne kombinacje.

Kompozycja (ang. composition) - Tworzenie nowych klas, używając klas już istniejących.
Agregacja (ang. aggregation) - kompozycja, do której dochodzi dynamicznie (w czasie wykonywania programu). Określana jest jako relacja typu 'posiada'

Dziedziczenie (ang. inheritance) - Tworzy nowy typ który kopiuje wszystkie składowe i interfejs klasy bazowej. W porównaniu do kompozycji, nie zapewnia takiej samej elastyczności, ponieważ ograniczenia na powstałe z niego klasy powstają już w czasie kompilacji.

Typ bazowy - posiada cecy i zachowania wspólne dla wszystkich jego typów pochodnych
Typ pochodny - reprezentuje spbą różne sposoby realizacji idei zawartych w typie bazowym 

Klasa pochodna może rozszerzać bazową (ang. extends), dodając nowe metowy nie stanowiące części interfejsu klasy bazowej. Może również zmienić (przesłonić - ang. overlay) jej zachowanie na nowo definiując jej metody.

Rzutowanie w górę (ang. upcasting) - traktowanie typu pochodnego jakby był typem bazowym

Rzutowanie w dół (ang. downcasting) - jest wykonywane w czasie działania programu (nie można stwierdzić, co będzie pod wskazanym adresem)

Typy parametryzowane / Typy ogólne (ang. parametrized types / generics) - klasy, które kompilator automatycznie przystosowuje do pracy z określonymi typami-parametrami. Przykład:
ArrayList<String> aList = new ArrayList<String>();

Garbage collector - Rozwiązanie zwalniania pamięci obiektów w Javie. Wszystkie obiekty dziediczą po klasie bazowej 'Object', wszystkie można tworzyć jedynie przez dodanie ich na stertę (Specjalny przypadek stanowią typy podstawowe), GC obsługuje zwalnianie pamięci - dzięki mniejszej ilości decyzji do podjęcia i potencjalnych problemów (takich jak wycieki pamieci w C++), programowanie w Javie staje się prostsze niż w C++.

Obsługa wyjątków (ang. exception handling) - Wyjątek stanowi obiekt który zostaje wyrzucony w miejscu wystąpienia błędu i może zostać obsłużony przez 'procedurę obsługi wyjątku' (ang. exception hanldler) przygotowaną do obsługi danego typu błędu. Zgłaszanie wyjątku nie może zostać zignorowane

Współbieżność/Wielowątkowość (ang. concurrency/multithreading) - Idea dzielenia wykonywanego zadania na niezależne fragmenty. W czasie korzystania z zasobów wspólnych, wątek blokuje zasób, wykonuje swoje zadanie i zwalnia blokadę, udostępniając innym wątkom dostęp.




Pomimo traktowania wszystkiego jako obiekt, jego identyfikator (nazwa) jest tak na prawdę referencją do obiektu. Referencję do obiektu typu String można utworzyć albo z wykorzystaniem słowa 'new':
    String value = new String("qwerty"); - Tworzy referencję do obiektu i inicjuje ją

Utworzyć jedynie referencję:
    String = value;

Wykorzystać specyfikę Javy - łańcuch tekstowy może być zainicjowany poprzez podanie wartości obiektu w cudzysłowie: 
    String value = "qwerty"; 

Słowo kluczowe 'new' można przetłumaczyć jako "Utwórz jeden nowy obiekt określonego typu"



Przechowywanie danych:
    1. Rejestry - Najszybciej dostępna pamięć (znajduje się wewnątrz procesora). Liczba rejestrów jest ograniczona a Java nie zapewnia mechanizmów bezpośredniej kontroli nad rejestrami (W C/C++ można manipolować danymi na poziomie kompilatora) 
    2. Stos - Znajduje się wewnątrz pamięci RAM, ale jest też obsługiwany przez procesor poprzez 'wskaźnik stosu'. Wskaźnik jest przesuwanu w dół (zajmowanie nowego obszaru w pamięci) albo w górę (zwalnianie obszaru pamięci). Żeby wygenerować kod odpowiedzialny za przesuwanie wskaźnika stosu, kompilator Javy musi znać rozmiar i czas życia wszystkich danych przechowywanych na stosie podczas tworzenia programu. W pamięci stosu w szczególności przechowywane są referencje do obiektów (same obiekty nie są tam ładowane) 
    3. Sterta - Fragment pamięci ogólnego zastosowania (Również w RAM), do którego ładowane są wszystkie obiekty Javy w momencie wywołania operatora 'new'. W przeciwieństwie do Stosu kompilator nie musi znać ani rozmiaru ani czasu życia danych przechowywanych na Stercie. Przydzielenie pamięci sterty zajmuje więcej czasu niż w przypadku stosu
    4. Obszar Stałych - Wartości stałe są umieszczane bezpośrednio w kodzie programu (W ten sposób są zabezpieczone przed jakimikolwiek zmianami). W niektórych przypadkach mogą zostać wydzielone z kodu, przez co mogą znaleźć się w pamięci ROM - przykładami mogą tu być pule ciągów znaków. Wszystkie literały łańcuchowe i inne stałe łańcuchowe mogą być wyodrębnione przez kompilator z kodu i przeniesione do specjalnego obszaru stałych
    5. Obszar spoza RAM - Dwa przykłady to strumieniowanie obiektów (przekształcanie obiektu w strumień bajtów) i obiekty trwałe (umieszczane na dysku - zachowują swój stan nawet po zakończeniu programu). Oba sposoby zamieniają obiekty w w coś co może zostać przechowane na innym medium i w razie potrzeby przekształcone w postaci stałego obiektu umieszczonego w pamięci RAM.
    Obecnie Java obsługuje 'trwałość lekką' (ang. lightweight persistence).
